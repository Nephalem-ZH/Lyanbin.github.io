[{"title":"Promise","date":"2019-01-28T03:29:32.000Z","path":"2019/01/28/Promise/","text":"一、最简单Promnise根据定义可知，promise是一个规范，规范并不在意promise是怎样create、reject，fulfill。规范只在意有木有一个then方法。根据我们下面的使用方式123456789let p = new MyPromise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(100); &#125;, 5000);&#125;);p.then(function (data) &#123; console.log(data);&#125;); 可以清楚的感知到，我们传入了个函数，这个函数会在内部执行。同时，then方法会注册一个回调，该回调在resolve后进行执行，并且拿到resolve的传参。那么，我们的promise可以简单定义为：12345678910111213141516171819202122232425262728293031323334353637383940414243function MyPromise(executor) &#123; let self = this; self.value = undefined; self.reason = undefined; self.onFulfilled = null; self.onRejected = null; function resolve(value) &#123; self.value = value; self.onFulfilled(value); &#125; function reject(reason) &#123; self.reason = reason; self.onRejected(reason); &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; console.log(e); &#125;&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; this.onFulfilled = onFulfilled; this.onRejected = onRejected;&#125;let p = new MyPromise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(100); &#125;, 5000);&#125;);p.then(function (data) &#123; console.log(data);&#125;); 二、不异步行不行要知道我们正常使用Promise传入的函数，可以是异步函数，可以是同步函数。但是，当我们试着给setTimeout干掉之后，会发现报错。1234567let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; console.log(data);&#125;); 具体的错误发生在上面的resolve定义的地方1234function resolve(value) &#123; self.value = value; self.onFulfilled(value);&#125; 因为resolve执行的时候，then注册的回调函数还没有挂载在self.onFulfilled上。解决办法很简单，只需将resolve方法的主体，使用setTimeout包裹即可。reject同理。则上面的最简单的MyPromise就变成了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function MyPromise(executor) &#123; let self = this; self.value = undefined; self.reason = undefined; self.onFulfilled = null; self.onRejected = null; function resolve(value) &#123; // 包个setTimeout setTimeout(() =&gt; &#123; self.value = value; self.onFulfilled(value); &#125;); &#125; function reject(reason) &#123; // 包个setTimeout setTimeout(() =&gt; &#123; self.reason = reason; self.onRejected(reason); &#125;); &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; console.log(e); &#125;&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; this.onFulfilled = onFulfilled; this.onRejected = onRejected;&#125;let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; console.log(data);&#125;); 三、状态我们都知道，每个promise具有3个状态。pending、fulfilled、rejected。在pending状态下可以分别向其他状态转换，而且fulfilled、rejected的状态不能改变。那么，MyPromise可以如下表示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function MyPromise(executor) &#123; let self = this; self.value = undefined; self.reason = undefined; // 加个状态 self.status = 'pending'; self.onFulfilled = null; self.onRejected = null; function resolve(value) &#123; if (self.status === 'pending') &#123; setTimeout(() =&gt; &#123; // 改变状态 self.status = 'fulfilled'; self.value = value; self.onFulfilled(value); &#125;); &#125; &#125; function reject(reason) &#123; if (self.status === 'pending') &#123; setTimeout(() =&gt; &#123; // 改变状态 self.status = 'rejected'; self.reason = reason; self.onRejected(reason); &#125;); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; console.log(e); &#125;&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; if (this.status === 'pending') &#123; // 如果是pending，则注册 this.onFulfilled = onFulfilled; this.onRejected = onRejected; &#125; else if (this.status === 'fulfilled') &#123; // 如果是fulfilled则直接执行 onFulfilled(); &#125; else if (this.status === 'rejected') &#123; // 如果是rejected则直接执行 onRejected(); &#125;&#125;let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; console.log(data);&#125;); 四、链式操作目前来看，只能使用一个then，要想使用promise.then(func1).then(func2).then(func3)这种操作，还需要对回调函数的注册进行一番改造。操作起来非常简单，只需在全局注册2个数组用来存放回调函数，在pending时push，在resolve时遍历回调数组，并挨个调用即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function MyPromise(executor) &#123; let self = this; self.value = undefined; self.reason = undefined; self.status = 'pending'; // 变成数组 self.onFulfilledCallbacks = []; self.onRejectedCallbacks = []; function resolve(value) &#123; if (self.status === 'pending') &#123; setTimeout(() =&gt; &#123; self.status = 'fulfilled'; self.value = value; // 遍历回调数组，并调用 self.onFulfilledCallbacks.forEach(callback =&gt; &#123; callback(self.value); &#125;); &#125;); &#125; &#125; function reject(reason) &#123; if (self.status === 'pending') &#123; setTimeout(() =&gt; &#123; self.status = 'rejected'; self.reason = reason; // 遍历循环数组，并调用 self.onRejectedCallbacks.forEach(callback =&gt; &#123; callback(self.value); &#125;); &#125;); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; console.log(e); &#125;&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; if (this.status === 'pending') &#123; this.onFulfilledCallbacks.push(onFulfilled); this.onRejectedCallbacks.push(onRejected); &#125; else if (this.status === 'fulfilled') &#123; onFulfilled(); &#125; else if (this.status === 'rejected') &#123; onRejected(); &#125; // 返回自己，才能链式操作 return this;&#125;let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; console.log(data);&#125;).then(function (data) &#123; console.log(data);&#125;); 上述代码看起来没啥问题，但是在诸如以下使用时，12345678910let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; setTimeout(() =&gt; &#123; console.log(data + 1); &#125;, 100);&#125;).then(function (data) &#123; console.log(data);&#125;); 会打印100 101。也就是说，第二个then先执行了。而且data的值，由于读的是同一个promise实例的data，在resolve的时候，也写死了，没有办法继续透传改变。要想实现每一个then都读上一个then的value，我们立刻可以想到，then应该返回一个新的promise，他拥有自己的data，这样一级一级往下传递，就实现了真正的异步串行操作。 五、then的改造回到上一节最后抛出的问题，上面的所有步骤，then中都直接返回了this，但是，问题来了，我们的需求为：每次调用then传参，取决于上一个then回调的返回值。看下面片段123456789101112131415161718MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this; let promise2; if (self.status === 'fulfilled') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; &#125;) &#125; else if (self.status === 'rejected') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; &#125;) &#125; else if (self.status === 'pending') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; &#125;) &#125;&#125; 可以看到，then中当前（对，当前，看清楚，我是说当前）的promise有3个状态，我们分别返回一个新的（新的，我new了，new了之后，下一级then内的this会变）promise。 另外考虑如下使用方式：12345678let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; return data + 200&#125;).then(function (data) &#123; console.log(data);&#125;); 我们希望最后的console.log(data)的结果是300，那么，在then的内部，promise2应该先拿到上一个MyPromise的值（也就是onFulfilled或者onRejected的值），然后马上resolve掉这个内部的promise。注意，这个resolve是为了传递内部的promise，也就是promise2的值，所以不管什么情况，最后只管resolve就是了。1234567891011121314151617181920212223242526272829303132333435363738394041424344MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this; let promise2; if (self.status === 'fulfilled') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; try &#123; let x = onFulfilled(self.data); resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125; else if (self.status === 'rejected') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; try &#123; let x = onRejected(self.data); resolve(x); &#125; catch (e) &#123; reject(e) &#125; &#125;); &#125; else if (self.status === 'pending') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; // 如果是`pending`状态，则一样只需给当前的数组压入回调即可 self.onFulfilledCallbacks.push((value) =&gt; &#123; try &#123; let x = onFulfilled(value); resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push((reason) =&gt; &#123; try &#123; let x = onRejected(reason); resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125;&#125; 到目前为止，看似都很美好。但是如果onFulfilled返回的x是一个新的MyPromise呢？所以，在Promise2中，不能简单的resolve这个promise2。我们这里定义个函数，用来专门处理x的值。123456789101112131415161718// 这里传入4个参数，x为promise2的onFulfilled或者onRejected的值，resolve和reject就是promise2的2个实参，至于为啥传递个`promise2`进来，后面我们慢慢完善，就发现他的作用了，这里暂时不管。function resolvePromise(promise2, x, resolve, reject) &#123; if (x instanceof MyPromise) &#123; // 如果x是promise的实例，则需要分类讨论是否pending if (x.status === 'pending') &#123; // 如果promise仍然是pending，则注册这个promise的回调函数，继续递归，直到返回值不是pending的promise为止 x.then(value =&gt; &#123; resolvePromise(promise2, value, resolve, reject); &#125;, reject); &#125; else &#123; // 如果promise以及被决断，则肯定有个resolve或者reject的值，直接调用then，拿到promise的最终值即可 x.then(resolve, reject); &#125; &#125; else &#123; // 如果x不是promise，直接resolve，降级为上面的x值非promise的情况 resolve(x); &#125;&#125; 这个函数是整个MyPromise中最抽象的地方。我们先分类讨论它的情况。 如果x的值不是MyPromise的实例，问题降级为上面x非promise的情况。 如果x的值是MyPromise的实例，但是状态已经被fulfilled或者rejected，则x肯定有一个最终的value，我们只需继续x.then(reolve, reject)，拿到x这个MyPromise的最终值即可。 如果x的值是MyPromise的实例，但是状态仍然是pending，我们同样需要调用then函数（promise每一步只能去then），去注册这个x的回调函数（再次啰嗦，x是MyPromise实例），继续递归，直到返回值不是pending状态的MyPromise为止。 至此，我们的MyPromise基本可用了，贴一下then方法此时的样子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this; let promise2; if (self.status === 'fulfilled') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; try &#123; let x = onFulfilled(self.data); // 替换 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125; else if (self.status === 'rejected') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; try &#123; let x = onRejected(self.data); // 替换 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e) &#125; &#125;); &#125; else if (self.status === 'pending') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; // 如果是`pending`状态，则一样只需给当前的数组压入回调即可 self.onFulfilledCallbacks.push((value) =&gt; &#123; try &#123; let x = onFulfilled(value); // 替换 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push((reason) =&gt; &#123; try &#123; let x = onRejected(reason); // 替换 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125;&#125; 组装完成后，配合下面的demo，可以查看 123456789101112let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; return new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(data + 100); &#125;, 2000); &#125;);&#125;).then(function (data) &#123; console.log(data);&#125;); 基本的Promise以及实现了，但是仍然有很多细节，我们慢慢补充。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"自适应照片墙布局","date":"2018-04-11T07:15:32.000Z","path":"2018/04/11/自适应照片墙布局/","text":"最近，业务上对照片处理的需求比较多，其中有一个照片瀑布流的效果，类似于500px，实现图片自适应的等高、无拉伸、无剪裁显示。大概效果如下图所示。 开始以为会有点好玩的算法，通过js简单控制图片的排列，后来发现，在已知每幅图的宽高的情况下，只需css即可实现这样的效果。 核心代码如下所示： 1234567&lt;div id=\"app\"&gt; &lt;div class=\"img-wrap\" v-for=\"item in imgs\" :style=\"`width: $&#123;item.width/item.height * 100&#125;px; flex-grow: $&#123;item.width/item.height * 100&#125;`\"&gt; &lt;i :style=\"`padding-bottom: $&#123;item.height/item.width * 100&#125;%`\"&gt;&lt;/i&gt; &lt;img :src=\"item.url\"&gt; &lt;/div&gt;&lt;/div&gt; 其中css为 1234567891011121314151617#app &#123; display: flex; flex-wrap: wrap;&#125;.img-wrap &#123; margin: 2px; background-color: violet; position: relative;&#125;i &#123; display: block;&#125;img &#123; position: absolute; top: 0; width: 100%;&#125; 接下来是原理。 首先高度要一致首先，看下最后的实现结果可以知道，每一行的高度要求持平，也就是说，在同一行中，所有图片的高度要求缩放到一致。那么，我们不妨设某一行的图片高度为100px。此时，该行图片中的某一张的已知真实宽高分别为w和h。此时，如果将h缩放至100px，那么可以知道，该图片的宽度应该为100w/h。也就是说，此时，承载这张图片的容器的样式应为 123&lt;div class=\"img-wrap\" v-for=\"item in imgs\" :style=\"`width: $&#123;item.width/item.height * 100&#125;px;\"&gt;&lt;/div&gt; 其次子元素撑开图片容器这里先提一下，当padding以及margin的值为百分比的时候，其实是相对于父级width的。也就是说，在业务中，很多情况下一些自适应的正方形块，我们可以通过子元素padding-bottom: 100%，意思是高度是父元素宽度的100%，这样就将父级元素撑成一个正方形。 而此时，并不是所有图片都是正方形，但是，我们已知图片的原有宽高，那么宽高的比例也是已知的，分别为w和h，那么也就是说，高度h是宽度w的h/w %。也就是说，我们只需将一个子元素的padding-bottom设置为h/w %，即可得到一个满足图片的原有比例图片容器。那么，此时图片的容器样式应该为 123&lt;div class=\"img-wrap\" v-for=\"item in imgs\" :style=\"`width: $&#123;item.width/item.height * 100&#125;px;\"&gt; &lt;i :style=\"`padding-bottom: $&#123;item.height/item.width * 100&#125;%`\"&gt;&lt;/i&gt;&lt;/div&gt; 那么这时候就会问了，开始咱们不是定了高度为100px么？ 最后两端对齐再看一眼我们最终要实现的结果，不但要求底部水平对齐，还要求两端对齐。用过flex就知道，只需将父元素设置为display: flex，子元素设置flex-grow: x即可。这时，x应该是多少呢？要知道，flex-grow是按照此比例，分配剩余的空间。又因为每个图片的大小是不一样的，所以，这个flex-grow的值当然是不一样的。细心的我们可以发现，其实比例，只需按照自身的宽度分配即可，也就是说，flex-grow：w/h*100，正所谓，胖子多得。。 那么问题就来了，宽度已经被flex-grow了，那么高度怎么办？高度还是100px么？显然不是了，但是看下上一小节中，我们对子元素的处理，用来撑开图片容器的子元素&lt;i&gt;的高度，也就是它的padding-bottom，是根据图片容器的宽度自适应的！那么，上一节的最后个疑问是不是已经打消了？ 换行换行就比较简单了，父元素设置flex-wrap: wrap即可。最终的代码完全体，就和开始一样。 最后回想开始的时候，我们假设的高度100px，这个值是可以根据自身的需要去简单调整的，这个初始值确定了之后，后续的flex-grow会在100px左右伸缩。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"React原理（四）setState","date":"2018-03-25T13:14:50.000Z","path":"2018/03/25/React原理（四）setState/","text":"在这一节中，我们将给Feact增加setState方法，这个方法非常有趣，端起饮料好好享受吧。 给Feact添加statestate和props非常相似，他们都是组件在渲染的时候，流动在内部的数据。不同的是props来自于外部，state是内部的。到目前为止，Feact只支持props，所以，在我们搞出setState之前，我们得先给这个小框架增加个state这个概念。 getInitialState当我们挂载一个新组件的时候，我们需要给这个组件增加一个初始state，这个时候，我们需要调用getInitialState这个生命周期函数。该生命周期函数需要在实例化的时候被调用，所以，我们需要在Feact.createClass构造函数里增加钩子。 123456789101112131415const Feact = &#123; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; const initialState = this.getInitialState ? this.getInitialState : null; this.state = initialState; &#125; Constructor.prototype = Object.assign(Constructor.prototype, spec); return Constructor; &#125;&#125; 就像props一样，我们给组件实例增加state、 注意，当我们组件没有getInitialState定义的时候，state的初始状态是null，React不会给state添加默认值为空对象。所以，当想使用state的时候，必须利用这个方法，返回一个对象。否则，如果在使用this.state.foo这样的操作的时候，第一次render会爆炸的哦。 现在，有了getInitialState，Feact组件可以随时使用this.state这个方法啦。 增加简单的setState()现在，我们准备给setState在Feact.createClass中，找一个合适的位置。为了实现它，我们将给所有的通过Feact.createClass创建的组件一个prototype，这个prototype将拥有一个setState方法。 123456789101112131415161718192021222324252627282930313233function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function () &#123; // TODO&#125;function mixSpecIntoComponent(Constructor, spec) &#123; const proto = Constructor.prototype; for (const key in spec) &#123; proto[key] = spec[key]; &#125;&#125;const Feact = &#123; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; const initialState = this.getInitialState ? this.getInitialState() : null; this.state = initialState; &#125; Constructor.prototype = new FeactComponent(); mixSpecIntoComponent(Constructor, spec); return Constructor; &#125;&#125; misSpecIntoComponent在React中，那可是相当的复杂，当然，也更健壮，它的角色更像是mixins，同时，保证用户在使用的时候，不会因为这个函数翻车。 让setState代入到updateComponent方法中回顾上一节，我们通过FeactCompositeComponentWrapper.receiveComponent来实现一个组件的更新，而这个函数接下来调用了updateComponent方法，所以，看起来我们只要通过updateComponent来处理state就能实现更新。那么，我们只需要将FeactComponent.prototype.setState和FeactCompositeComponentWrapper.receiveComponent打通即可。 在React中，有『公共实例』和『内部实例』的概念。公共实例是通过createClass创建的组件的实例，内部实例是React内部对象的实例。那么，在这些概念下，内部实例就是FeactCompositeComponentWrapper，不难发现，内部实例能够感知到公共实例的一切，但是反过来却不行。现在，我们准备改变这个。setState是公共实例给内部实例通信的方法，带着这个想法，看如下实现 1234567891011function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function (partialState) &#123; const internalInstance = getMyInternalInstancePlease(this); internalInstance._pendingPartialState = partialState; FeactReconciler.performUpdateIfNecessary(internalInstance);&#125; React解决getMyInternalInstancePlease这个问题的方法是通过一个实例映射，这个映射保存了某个公共实例内的内部实例。 123456789const FeactInstanceMap = &#123; set(key, value) &#123; key.__feactInternalInstance = value; &#125;, get(key) &#123; return key.__feactInternalInstance; &#125;&#125; 而这个映射关系的建立，是在组件挂载的时候。 12345678910111213const FeactCompositeComponentWrapper &#123; // 其他都一样 mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); this._instance = componentInstance; FeactInstanceMap.set(componentInstance, this); &#125;&#125; 现在，还有一个没有用到的方法，FeactReconciler.performUpdateIfNecessary，这个方法就像其他的协调器方法一样 12345678910111213141516const FeactReconciler &#123; // 其他都一样 performUpdateIfNecessary(internalInstance) &#123; internalInstance.performUpdateIfNecessary(); &#125;&#125;class FeactCompositeComponentWrapper &#123; // 其他都一样 performUpdateIfNecessary() &#123; // 注意这里，一样哦 this.updateComponent(this._currentElement, this._currentElement); &#125;&#125; 最终，我们终于调用了updateComponent，但是请注意，这里我们做了一点HACK，虽然我们调用了更新，但是，我们传递了相同的两个参数。任何时候，当updateComponet传递了相同的元素，React就知道，只有state更新了，否则就是props更新了。React会通过prevElement !== nextElement来判断是否调用componentWillReceiveProps，所以，这里先改造下Feact，让它也做相同的处理。 123456789101112131415class FeactCompositeComponentWrapper &#123; // 其他都一样 updateComponent(prevElement, nextElement) &#123; const nextProps = nextElement.props; const inst = this._instance; const willReceive = prevElement !== nextElement; if (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123; inst.componentWillReceiveProps(nextProps); &#125; // 其他都一样 &#125;&#125; 这个只是updateComponent的片段，只是为了解决setState()并不会导致componentWillReceiveProps在渲染前的调用。也就是说，setState无需影响到props。 通过新的state更新现在处理updateCompoent，内部实例已经通过internalInstance._pendingPartialState获取到了新的state，所以现在我们需要做的，仅仅是让这个组件再渲染一次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class FeactCompositeComponentWrapper &#123; // 其他都一样 updateComponent(prevElement, nextElement) &#123; const nextProps = nextElement.props; const inst = this._instance; const willReceive = prevElement !== nextElement; if (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123; inst.componentWillReceiveProps(nextProps); &#125; let shouldUpdate = true; const nextState = Object.assignn(&#123;&#125;, inst.state, this._pendingPartialState); this._pendingPartialState = null; if (inst.shouldComponentUpdate) &#123; shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState); &#125; if (shouldUpdate) &#123; this._performComponentUpdate(nextElement, nextProps, nextState); &#125; else &#123; inst.props = nextProps; inst.state = nextState; &#125; &#125; _performComponentUpdate(nextElement, nextProps, nextState) &#123; this._currentElement = nextElement; const inst = this._instance; inst.props = nextProps; inst.state = nextState; this._updateRenderedComponent(); &#125; _updateRenderedComponent() &#123; const prevComponentInstance = this._renderedComponent; const inst = this._instance; const nextRenderedElement = inst.render(); FeactReconciler.receiveComponent( prevComponentInstance, nextRenderedElement ); &#125;&#125; 组件的更新跟之前很像，不同的是，我们增加了state的赋值操作。因为state仅仅挂载在公共实例上，_performComponentUpdate只改变了一行，_updateRenderedComponent一行没变。真正改变的重点就是在updateComponent中，我们合并state的操作。 至此，setState的功能，已经基本完成啦！ 但是，上面的setState的实现，比较屌丝，性能也比较糟糕。主要的问题是，每次调用setState都会导致组件的渲染。这将迫使用户，要么好好想想怎么组装数据然后只使用一次setState，要么就接受这种每次调用就渲染的问题。接下来，我们要做的就是改造它，使它最好能自适应的具有批量工作的能力，从而减少渲染的次数。 批量调用setState仔细观察生命周期函数的调用，不难发现，每次的渲染，都调用了componentWillReceiveProps。如果用户在componentWillReceiveProps中调用setState会发生什么？在当前的代码中，这将会导致在第一次渲染过程中又一次新的渲染，而对state改版而造成的props的响应，画面太美不敢看。所以，我们最好将一系列的state和props的改变，都塞到同一次渲染中。 首先我们需要给需要批量的操作保存起来首先想到的就是改造_pendingPartialState，让它成为一个数组。 123456789101112function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function (partialState) &#123; const internalInstance = FeactInstanceMap.get(this); internalInstance._pendingPartialState = internalInstance._pendingPartialState || []; internalInstance._pendingPartialState.push(partialState); // 其他都一样&#125; 而在updateComponent中，调用我们将要设计的合并state方法。 1234567891011121314151617181920212223242526class FeactCompositeComponentWrapper &#123; // 其他都一样 updateComponent(prevElement, nextElement) &#123; // 其他都一样 const nextState = this._processPendingState(); // 其他都一样 &#125; _processPendingState() &#123; const inst = this._instance; if (!this._pendingPartialState) &#123; return inst.state; &#125; let nextState = inst.state; for (let i = 0; i &lt; this._pendingPartialState.length; ++i) &#123; nextState = Object.assign(nextState, this._pendingPartialState[i]); &#125; this._pendingPartialState = null; return nextState; &#125;&#125; 其次将批量合并之后的state塞到一次渲染过程中 注意这里的批量操作原理是非常简单的，并不是React中的全部功能。我们主要指出批量操作的原理。 在Feact中，我们只在页面还在渲染的时候，批量合并state，其他时候，我们并不做这样的处理。所以，在updateComponent过程中，我们会做一个标记，告诉外面，我们正在渲染，在渲染结束之后，讲其设置为false。如果setState看到了这个标记为true，他会挂起这个state，但不渲染它。因为它知道，当当前的渲染结束的时候，渲染引擎会重拾这个state进行下一次渲染。 12345678910111213141516171819202122232425262728class FeactCompositeComponent &#123; // 其他都一样 updateComponent(prevElement, nextElement) &#123; this._rendering = true; // 中间这一部分跟之前一样 this._rendering = false; &#125;;&#125;function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function (partialState) &#123; const internalInstance = FeactInstanceMap.get(this); internalInstance._pendingPartialState = internalInstance._pendingPartialState || []; internalInstance.push(partialState); if (!internalInstance._rendering) &#123; FeactReconciler.performUpdateIfNecessary(internalInstance); &#125;&#125; 基本上完成啦。 setState陷阱现在，我们已经明白了setState的工作原理以及批量工作的概念，但是这里有几个关于setState的陷阱需要注意。我们知道，当我们利用state去更新组件的时候，有好几个步骤，每个步骤中，被挂起的state需要一个一个的处理，也就是说，当我们在setState中使用this.state是非常危险的 1234componentWillReceiveProps(nextProps) &#123; this.setState(&#123; counter: this.state.counter + 1 &#125;); this.setState(&#123; counter: this.state.counter + 1 &#125;);&#125; 这个例子中，我们期待执行2次加法运算。但是，state会被批量处理，所以第二次setState和第一次的setState有相同的输入，所以，加法运算只会执行一次。 React中，解决这个问题的方法是传入一个回调函数 12345678componentWillReceiveProps(nextProps) &#123; this.setState((currentState) =&gt; (&#123; counter: currentState.counter + 1 &#125;); this.setState((currentState) =&gt; (&#123; counter: currentState.counter + 1 &#125;);&#125; 当传入回调函数的时候，我们将会得到正确的结果，我们将这个特性运用到Feact中去 123456789101112131415161718192021_processPendingState() &#123; const inst = this._instance; if (!this._pendingPartialState) &#123; return inst.state; &#125; let nextState = inst.state; for (let i = 0; i &lt; this._pendingPartialState.length; ++i) &#123; const partialState = this._pendingPartialState[i]; if (typeof partialState === 'function') &#123; nextState = partialState(nextState); &#125; else &#123; nextState = Object.assign(nextState, patialState); &#125; &#125; this._pendingPartialState = null; return nextState;&#125; 至此，大功告成啦！","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React原理（三）更新","date":"2018-03-19T09:08:21.000Z","path":"2018/03/19/React原理（三）更新/","text":"上两篇中，React具有了基本的渲染能力。但是，一旦渲染发生，就不能再改变了。这一篇中，我们将在render中，添加更新功能,并且，将简单的展示虚拟dom的diff过程。 简单更新让React应用实现更新，最普通的办法就是调用组件的setState()方法。但是，React也支持通过React.render()来实现更新。就像如下所示： 12345React.render(&lt;h1&gt;hello&lt;/h1&gt;, root);setTimeout(() =&gt; &#123; React.render(&lt;h1&gt;hello again&lt;/h1&gt;, root);&#125;, 2000) 本篇中，我们暂时忽略setState()，先通过Feact.render()来实现更新。说实话，这就是最屌丝的『props改变，所以更新』的模型，即如果你又render了，并且传入了不同的props给子组件，那么就更新呗。 开始理念非常简单，Feact.render()只需检查，之前是否渲染过，如果渲染过，就执行update。结构如下所示 123456789101112131415161718192021222324252627282930313233343536const Feact = &#123; // 其他都一样 render(element, container) &#123; const prevComponent = getTopLevelComponentInContainer(container); if (prevComponent) &#123; return updateRootComponent( prevComponent, element ); &#125; else &#123; return renderNewRootComponent(element, container); &#125; &#125; // 其他都一样&#125;function renderNewRootComponent(element, container) &#123; // 这个函数就是之前的render内的逻辑 const wrapperElement = Feact.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); return FeactReconciler.mountComponent(componentInstance, container);&#125;;function getTopLevelComponentInContainer(container) &#123; // TODO&#125;function updateRootComponent(prevComponent, nextElement) &#123; // TODO&#125; 看起来很美好，如果之前渲染过，则将之前的组件和更新后的组件，传递给一个函数，这个函数将计算出dom所需要做出的更新动作。否则，就像上一篇所讲的那样，直接将组件渲染进来即可。那么，问题已经被降级为搞定我们缺失的2个函数。 记住我们所做的对于每一次渲染，我们需要记录那些我们渲染过的组件，以获取他们的引用，方便后续的渲染。咋整呢？最好的方法就是在创建dom节点的时候，做上一个标记。 123456789101112131415function renderNewRootComponent(element, container) &#123; const wrapperElement = Feact.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); // 注意这里操作 const markUp = FeactReconciler.mountComponent(componentInstance, container); // 多了这么一行，这里将组件的实例保存到container上 // 这里我们想要的是组件实例的_renderedComonent, 因为componentInstance是最顶级的一个壳子，无需更新 // 还记得_renderedComponent么？在上一节的预挂载函数内，我们偷摸的保存了下。 container.__feactComponentInstance = componentInstance._renderedComponent; return markUp;&#125; 那么，对于已经挂在的组件的情况，一样的返回container.__feactComponentInstance。 123function getTopLevelComponentInContainer(container) &#123; return container.__feactComponentInstance;&#125; 更新首先先看一个简单的示例。 123456789101112Feact.render( Feact.createElement('h1', null, 'hello'), root);setTimeout(() =&gt; &#123; Feact.render( Feact.createElement('h1', null, 'hello again'), root );&#125;, 2000); 2秒后，我们又一次调用了Feact.render()，但是，这次调用所传入的元素大概长这样 123456&#123; type: 'h1', props: &#123; children: 'hello again' &#125;&#125; 当Feact确定了这是一个更新动作，则会进入到updateRootComponent()函数中， 1234function updateRootComponet(prevComponet, nextElement) &#123; prevComponent.receiveComponent(nextElement);&#125;; 这里注意，我们没有创建一个新的组件，prevComponent是我们第一次渲染的时候就创建的组件，现在只是更新了它自己而已。所以，组件一旦被创建，它将一直存在，直到被卸载（unmount）。 再来考虑FeactDOMComponent 12345678910111213141516171819202122232425262728class FeactDOMComponent &#123; // 其他都一样 receiveComponent(nextElement) &#123; const prevElement = this._currentElement; this.updateComponent(prevElement, nextElement); &#125; updateComponent(prevElement, nextElement) &#123; const lastProps = prevElement.props; const nextProps = nextElement.props; this._updateDOMProperties(lastProps, nextProps); this._updateDOMChildren(lastProps, nextProps); this._currentElement = nextElement; &#125;; _updateDOMProperties(lastProps, nextProps) &#123; // 更新css &#125; _updateDOMChildren(lastProps, nextProps) &#123; // 更新组件 &#125;&#125; receiveComponent()只是调用了updateComponent()，而updateComponent()则最终调用了_updateDOMProperties()和_updateDOMChildren()，这2个函数最终，完成了真实dom的更新。需要注意的是，_updateDOMProperties()更多的关注了CSS相关的内容。简便期间，我们暂时不考虑它，仅仅指出，在React中，这个函数是用来解决样式的更新的。 _updateDOMChildren()在React中，那可是相当的复杂，主要是解决了各种不同的场景下的执行情况。但是，在Feact中，为了方便理解，我们只考虑子节点是文本的情况，也就是上文中所写的，我们从hello，更新到了hello again。 123456789101112131415161718192021222324252627class FeactDOMComponent &#123; // 其他都一样 _updateDOMChildren(lastProps, nextProps) &#123; const lastContent = lastProps.children; const nextContent = nextProps.children; if (!nextContent) &#123; this.updateTextContent(''); &#125; else if (lastContent !== nextContent) &#123; this.updateTextContent('' + nextContent); &#125; &#125; _updateTextContent(text) &#123; const node = this._hostNode; const firstChild = node.firstChild; if (firstChild &amp;&amp; firstChild === node.lastChild &amp;&amp; firstChild.nodeType ===3) &#123; firstChild.nodeValue = text; return; &#125; node.textContent = text; &#125;&#125; 从上面可以看出，Feact的_updateDOMChildren非常屌丝，但是大概原理就是这样。 更新自定义组件上面这些内容，我们实现了FeactDOMComponent的更新，但是下面这种情况就无能为力了。 123456789101112Feact.render( Feact.createElement(MyCoolComponent, &#123;myProp: 'hello'&#125;), document.getElementById('root'););setTimeout(() =&gt; &#123; Feact.render( Feact.createElement(MyCoolComponent, &#123;myProp: 'hello again'&#125;), document.getElementById('root'); );&#125;, 2000); 更新自定义组件就有趣多了，这也是React的牛逼之处。有一个好消息，自定义组件的更新，归根结底会降级到原生组件的更新，所以上面我们做的工作，都是有效的，没有浪费。 还有个更好的消息，updateRootComponent在执行的时候，并不关心组件是自定义的组件，还是原生的组件。他只是调用receiveComponent，所以，我们需要做的，只是给FeactCompositeComponentWrapper也增加一个receiveComponent就好啦。 1234567891011121314151617181920212223242526272829303132class FeactCompositeComponentWrapper &#123; // 其他都一样 receiveComponent(nextElement) &#123; const prevElement = this._currentElement; this.updateComponent(prevElement, nextElement); &#125; updateComponent(prevComponent, nextElement) &#123; const nextProps = nextElement.props; this._performComponentUpdate(nextElement, nextProps); &#125; _performComponentUpdate(nextElement, nextProps) &#123; this._currentELement = nextElement; const inst = this._instance; inst.props = nextProps; this._updateRenderedComponent(); &#125; _updateRenderedComponent() &#123; const prevComponentInstance = this._renderedComponent; const inst = this._instance; const nextRenderedElement = inst.render(); prevComponentInstance.receiveComponent(nextRenderedElement); &#125;&#125; 这里有点点复杂，但是也解决了很多问题，而且，React中，基本跟我们写的一样，一样的在ReactCompositeComponentWrapper有上面我们写的4个函数。 最终，这些一系列复杂的更新操作，都会降级到去render一系列的props，然后，把得到的结果传递给_renderedComponent进行更新。_renderedComponent会变成下一个FeactCompositeComponentWrapper或者FeactDOMComponent。 使用协调器挂载组件当然要通过我们之前所写的FeactReconciler，虽然这个操作对于Feact没什么意义，但是我们还是保持和React一致。 123456789101112131415161718192021222324252627282930const FeactReconciler = &#123; // 其他都一样 receiveComponent(internalInstance, nextElement) &#123; internalInstance.receiveComponent(nextElement); &#125;&#125;function updateRootComponentprevComponent, nextElement) &#123; FeactReconciler.receiveComponent(prevComponent, nextElement);&#125;class FeactCompositeComponentWrapper &#123; // 其他都一样 _updateRenderedComponent() &#123; const prevComponentInstance = this._renderedComponent; const inst = this._instance; const nextRenderedElement = inst.render(); FeactReconciler.receiveComponent( prevComponentInstance, nextRenderedElement ); &#125;&#125; 生命周期shouldComponentUpdate和componentWillReceiveProps1234567891011121314151617181920212223class FeactCompompositeComponentWrapper &#123; // 其他都一样 updateComponent(prevElement, nextElement) &#123; const nextProps = nextElement.props; const inst = this._instance; if (inst.componentWillReceiveProps) &#123; inst.componentWillReceiveProps(nextProps); &#125; let shouldUpdate = inst.shouldComponentUpdate(nextProps); if (shouldUpdate) &#123; this._performComponentUpdate(nextElement, nextProps); &#125; else &#123; // 即使不更新，也要更新下最新的props inst.props = nextProps; &#125; &#125;&#125; 还有个大坑到目前为止，还有个很大的问题不知你们发现了没，那就是现在所有的更新，都是假设更新的时候，都是使用了相同的组件，也就是说，下面这种情况我们可以更新 1234567891011Feact.render(&#123; Feact.createElement(MyCoolComponent, &#123;myProp: 'hi'&#125;), root&#125;);setTimeout(() =&gt; &#123; Feact.render( Feact.createElement(MyCoolComponent, &#123; myProp: 'hi again' &#125;), root );&#125;, 2000) 但是，下面这种情况更新不了 1234567891011Feact.render( Feact.createElement(MyCoolComponent, &#123;myProp: 'hi'&#125;), root);setTimeout(() =&gt; &#123; Feact.render( Feact.createElement(SomeOtherComponent, &#123;someOtherProp: 'hmmm' &#125;), root );&#125;, 2000) 这个例子中，我们传入了一个全新的组件，Feact非常弱智的继续渲染原来的MyCoolComponent，然后把他的props更新为{someOtherProp: &#39;hmmm&#39; }。 正确的做法是告诉它，组件的type已经改变了，不应该再去更新，应该卸载掉MyCoolComponent，然后挂载SomeOtherComponent。 想实现这些，Feact必须做到以下2点： 具有卸载组件的能力（unmount） 通知组件的type已经改变，然后让FeactReconciler执行FeactReconciler.mountComponent，而不是去去执行FeactComponent.receiveComponent 在React中，如果你又一次渲染了相同的组件，那么它会更新。这时候，你不需要定义一个key给你的组件。key仅仅在需要渲染成吨的children的时候，是必要的。如果你忘记了给渲染的子组件增加key，React会给你一堆警告，你最好留意这些警告，因为如果没这些key的话，React在需要更新的时候执行的不是更新，而是卸载掉原来的组件，然后挂载新的。 现在知道什么是虚拟DOM了么在React刚出来的时候，各种吹所谓的虚拟DOM，但是我觉得虚拟DOM并不是真的需要关心的。他仅仅是一些概念而已。真正需要关注的，是prevElement和nextElement，他们一起捕获了每次渲染不同的地方，然后FeactDOMComponent将这些不同的地方挂载到了真实的DOM上。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React原理（二）生命周期","date":"2018-03-15T09:30:55.000Z","path":"2018/03/15/React原理（二）生命周期/","text":"上一篇中，简单的介绍了ReactJs的渲染结构，这里，会对组件的生命周期进行简单的分析。 首先，对createClass()这个函数进行简单的处理。 上一节，createClass()如下所示： 12345678910111213const Feact = &#123; // 其他都一样 createClass (spec) &#123; function Constructor(props) &#123; this.props = props; &#125; Constructor.prototype.render = spec.render; return Constructor; &#125;&#125; 从上面可以看出，render()方法仅仅接收了子组件的render方法，这里可以简单处理下，将整个spec挂载到组件的原型上去。让Constructor()能够继承包括componentWillMount等更多的属性和方法。 12345678910111213const Feact = &#123; // 其他都一样 createClass (spec) &#123; function Constructor(props) &#123; this.props = props; &#125; Constructor.prototype = Object.assign(Constructor.prototype, spec); return Constructor; &#125;&#125; 接下来，我们开始改造FeactCompositeComponentWrapper对象。 在上一章中，我们记得，FeactCompositeComponentWrapper的mountComponent()方法走了个『捷径』，疯狂递归子组件的render方法，直到出现一个原生的dom对象为止。现在有一个问题，循环的过程中，这个『捷径』仅仅调用了子组件的render()方法，而生命周期函数却无处安放。 1234567891011121314151617181920class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentELement = element; &#125; mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); let element = componentInstance.render(); while (typeof element.type === 'function') &#123; element = (new element.type(element.props)).render(); &#125; const domComponentInstance = new FeactDomComponent(element); domComponentInstance.mountComponent(container); &#125;&#125; 从上面可以看出，mountComponent逐步向下，直到找到原生的组件。只要render()返回了一个自定义组件，他就会继续调用render()，直到得到一个原生的组件。这就导致了，这些子组件，没有办法参与到整个挂载的生命周期中去。换句话说，它们的render()方法是被调用了，但是也就是仅仅被调用了而已。现在，我们需要做的事情，就是将每一个完整组件参与到整个挂载过程中。 现在，开始改造下FeactCompositeComponentWrapper对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentELement = element; &#125; mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); // let element = componentInstance.render(); // while (typeof element.type === 'function') &#123; // element = (new element.type(element.props)).render(); // &#125; this._instance = componentInstance; const markup = this.performInitialMount(container); return markup; // const domComponentInstance = new FeactDomComponent(element); // domComponentInstance.mountComponent(container); &#125; performInitialMount(container) &#123; const renderedElement = this._instance.render(); const child = instantiateFeactComponent(renderedElement); // 这一行暂时没用，以后将负责关于更新相关的操作 this._renderedComponent = child; return FeactReconciler.mountComponent(child, container); &#125;&#125;const FeactReconciler = &#123; mountComponent(internalInstance, container) &#123; return internalInstance.mountComponent(container); &#125;&#125;function instantiateFeactComponent(element) &#123; if (typeof element.type === 'string') &#123; return new FeactDOMComponent(element); &#125; else if (typeof element.type === 'function') &#123; return new FeactCompositeComponentWrapper(element); &#125;&#125; 一下子写了介么多代码，传递了一个基本的思想，就是将mounting的过程，单独提出来。也就是FeactReconciler的作用，它将在以后承担更多的工作。在React中，也存在一个ReactReconciler，跟我们的FeactReconciler一样。 处理 Feact.render()Feact.render()在上一章中，调用了componentInstance.mountComponent(container)，现在，讲其更新为我们的刚刚写的FeactReconciler 123456789101112const Feact = &#123; // 其他都一样 render(element, container) &#123; const warpperElement = this.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); return FeactReconciler.mountComponent( componentInstance, container ); &#125;&#125; 至此，所有的自定义组件，已经被完全挂载，这些自定义组件将参与到整个挂载的生命周期中去。 最后，增加componentWillMount和componentDidMount 接下来就简单啦，增加钩子函数即可。 1234567891011121314151617181920212223242526class FeactCompositeComponentWrapper &#123; // 其他都一样 mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); this._instance = componentInstance; if (componentInstance.componentWillMount) &#123; componentInstance.componentWillMount(); &#125; const markUp = this.performInitialMount(container); if (componentInstance.componentDidMount) &#123; componentInstance.componentDidMount(); &#125; return markUp; &#125;, // 其他都一样&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React原理（一）渲染","date":"2017-10-19T09:37:55.000Z","path":"2017/10/19/React原理（一）渲染/","text":"React是声明式的在React中，写一个组件，通常会这么写12345class Mycomponent extends React.Component &#123; render () &#123; return &lt;div&gt;hello&lt;/div&gt; &#125;&#125; 其中，return的内容，会被编译为12345class Mycomponent extends React.Component &#123; render () &#123; return React.createElement('div', null, 'hello'); &#125;&#125; 在某种意义上说，我们是通过调用了React.createElement来创建一个组件。但是，事实上我们仅仅是声明了这个组件，然后React帮助我们实例化了这个组件对象，并调用render()来创建了这个组件。我们仅仅需要描述我们需要什么，剩下的全部由React渲染页面。 React的渲染基础渲染原理接下来，靠着这个思想，来创建一个假的React，这里暂且叫它为Feact吧。 首先，要实现React，我们分解问题来看，就是要实现一个 1Feact.render(&lt;h1&gt;hello world&lt;/h1&gt;, document.getElementById('root')); 简单了解React就会知道，render()方法的第一个参数，是jsx语法，这里暂时不考虑jsx的编译，问题继续被降级，那么就是要实现一个 1234Feact.render( Feact.createElement('h1', null, 'hello world'), document.getElementById('root')); 也就是说，Feact对象中，目前必须得有2个方法，一个是createElement(), 一个是render()。其中，createElement()方法返回一个普通的json对象，来描述dom。所以，目前，我们的Feact对象应该张这个样子 1234567891011121314151617const Feact = &#123; createElement(type, props, children) &#123; const element = &#123; type, props: props || &#123;&#125; &#125;; if (children) &#123; element.props.children = children; &#125; return element; &#125; render() &#123; &#125;&#125; 那么render函数，从上面可以得知，render()接收两个参数，一个是描述dom的对象，一个是被插入的位置。也就是说render()应该长的像这样子 1234render(element, container) &#123; const componentInstance = new FeactDomComponent(element); return componentInstance.mountComponent(container);&#125; 其中，FeactDomComponent对象用来生成dom，然后调用该对象中的mountComponent方法来实现挂载。所以FeactDomComponent对象至少应该是这个样子 123456789101112131415161718192021class FeactDomComponent &#123; /* element 即为描述dom的json对象 */ constructor(element) &#123; this._currentElement = element; &#125; mountComponent(container) &#123; const domElement = document.createElement(this._currentElement.type); const text = this._currentElement.props.text; const textNode = document.createTextNode(text); domElement.appendChild(textNode); container.appendChild(domElement); // 这里暂时没啥用，后面更新的时候会用到 this._hostNode = domElement; return domElement; &#125; &#125; 给以上代码组装下，一个最基本的Feact就组件完成了。 用户自定义组件以上得到的仅仅是一个写死的组件，下面加入用户可配置功能。所以，Feact需要添加一个createClass()方法。 123456789101112131415161718192021222324252627282930313233const Feact = &#123; createElement() &#123; /* 跟上头一样 */ &#125; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; &#125; Constructor.prototype.render = spec.render; return Constructor; &#125; render(element, container) &#123; // 之前的render不能接收用户自定义的组件，这里待会儿修改 &#125; &#125;;const MyTitle = Feact.createClass(&#123; render() &#123; return Feact.createElement('h1', null, this.props.message); &#125;&#125;);Feact.render(&#123; Feact.createElement(MyTitle, &#123; message: 'i am here' &#125;), document.getElementById('root')&#125;); 现在，可以Feact可以接收自定义的组件了。就差改写render()方法了。但是，目前来看，render()方法利用FeactDomComponent对象仅仅处理原生的dom。需要进行改造，添加一个FeactCompositeComponentWrapper来包裹FeactDomComponent对象 12345678910111213141516171819202122render(element, container) &#123; const componentInstance = new FeactCompositeComponentWrapper(element); return componentInstance.mountComponent(container);&#125;class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentElement = element; &#125; mountComponent(container) &#123; /* 目前Component是一个构造函数 */ const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); const element = componentInstance.render(); const domComponentInstance = new FeactDOMComponent(element); return domComponentInstance.mountComponent(container); &#125;&#125; 到目前为止，Feact已经能处理一些用户自定义的组件以及原生组件，但是在render()方法中，假如存在自定义组件嵌套的话，目前还不能胜任，比如一个组件如下所示，MyMessage嵌套了Mytitle： 1234567891011const MyMessage = Feact.createClass(&#123; render() &#123; if (this.props.asTitle) &#123; return Feact.createElement(Mytitle, &#123; message: this.props.message &#125;); &#125; else &#123; return Feact.createElement('p', null, this.props.message) &#125; &#125;&#125;); 这样的话，我们必须在FeactCompositeComponentWrapper中的mountComponent方法里，做一些简单的逻辑判断。那么，FeactCompositeComponentWrapper改写为： 123456789101112131415161718class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentELement = element; &#125; mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); let element = componentInstance.render(); while (typeof element.type === 'function') &#123; element = (new element.type(element.props)).render(); &#125; const domComponentInstance = new FeactDomComponent(element); domComponentInstance.mountComponent(container); &#125;&#125; 目前来看，Feact已经更加完善了，但是目前的生命周期还有问题，后续再解决。另外，在Feact.render()执行的时候，无论组件是自定义组件还是原生的dom，我们发现他们终归会执行到FeactDOMComponent，所以这里为了统一处理，我们可以给所有的组件包裹一个工厂函数，让他成为自定义组件，方便我们后续处理。 工厂函数很简单，如下所示 123456789101112131415const TopLevelWrapper = function (props) &#123; this.props = props;&#125;TopLevelWrapper.prototype.render = function () &#123; return this.props;&#125;const Feact = &#123; render(element, container) &#123; const warpperElement = this.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); return componentInstance.mountComponent(container); &#125;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"换手巾","date":"2017-04-24T08:53:46.000Z","path":"2017/04/24/换手巾/","text":"2017年4月22日，农历三月廿六，我和博哥向前，又迈了一步。匆匆又匆匆，7年了。 在离开家的这12年里，自信、失落、孤独、荣誉、蹉跎，我们终于走到了今天。 换手巾，在我的家乡，就是订婚的意思。 年轻的男女，用大红的方巾，小心翼翼的将定情信物包起来，在亲朋好友的见证下，互相赠予对方。 「从今往后，你就是我的人了，择良辰吉日，娶你回家。」 「从今往后，我就是你的人了，择良辰吉日，娶我回家。」 对，这就是订婚了。 从长辈那里得知，家里的订婚，甚至比结婚还要正式。因为换手巾时，来的人，都是血脉至亲。 曾今因为这事情，跟长辈出现严重的分歧，在我心里，从来对这种极具形式主义的活动没任何兴趣。 总觉得，这些形式上的东西，总是这样、那样的阻挠我。 但是， 当司仪，庄严的宣布的时候，谁会不激动？ 当亲朋好友，送出祝福的时候，谁会不激动？ 当父母，泪花闪烁的时候，谁会不激动？ 送出的不但是祝福，更是一种传承。 本是幸福日子，哪怕过程多么曲折，多么艰辛，都是值得的！ 过了那一刻，我也仿佛真的认识到了很多。 或者说我已经不在幼稚，或许说我终于认识到了自己的责任，或许说，我终于肯回头看了下， 那走的太快，而落下的灵魂。 三伯的死，让人难受。 谁又能永生？我身边的人终将会一个个倒下，但是我现在好害怕，好害怕，好害怕。 我看到了爸爸的白发，看到了妈妈的皱纹， 应和着幸福的我们， 更白了，更深了。 这1年多来，我变得不再沉着冷静，怀疑身边的一切，总觉得命运叵测，让我沦落至今。 念书怀疑毕业，毕业怀疑找工作，找工作怀疑部门，部门怀疑领导的看法，怀疑升职，怀疑加薪，怀疑自己的生存。 有用么？没有一点用。种瓜得瓜种豆得豆，除了应有的收获，留下的，是自己的身心疲惫。 从今天起，捡起初心，做一个善良的人。 爸妈，我爱你们。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"诚惶诚恐","date":"2017-04-18T07:35:26.000Z","path":"2017/04/18/诚惶诚恐/","text":"新的开始，希望一切步入正轨。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"React 101","date":"2017-03-28T08:34:40.000Z","path":"2017/03/28/React-101/","text":"临走前坑一把，体验一把React。本篇即为新手入门的101。 一、快速开始以下为通常情况下的组件创建12345678910111213141516171819202122232425262728import React from 'react';import ReactDOM from 'react-dom';// 注意组件开头第一个字母都要大写class App extends React.Component &#123;// 若是需要绑定 this. 方法或是需要在 constructor 使用 props ，定义 state ，就需要 constructor 。若是在其他方法（如 render）使用 this.props 则不用一定要定义 constructor constructor(props) &#123;// extends 可以继承 React.Component 。super 方法可以呼叫继承父类构造函数。 super(props);// 初始化 state，等于 ES5 中的 getInitialState this.state = &#123; &#125;; &#125;// render 是 Class based 组件唯一必须的方法（method）// 每个组件，只能有一个顶级标签！！！！ render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;// 将 &lt;App /&gt; 组件插入 id 为 app 的 DOM 元素中ReactDOM.render(&lt;App /&gt;, document.getElementById('app')); 当创建的组件仅仅为无状态组件时，可以使用剪头函数快捷创建12345678//const MyComponent = () =&gt; ( &lt;div&gt;Hello, World!&lt;/div&gt;);// 将 &lt;MyComponent /&gt; 组件插入 id 为 app 的 DOM 元素中ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById('app')); 为了提高组件的健壮性，通常会对传入的props进行验证。123456789101112// PropTypes 验证，若传入的 props type 不符合将会显示错误App.propTypes = &#123; todo: React.PropTypes.object, name: React.PropTypes.string,&#125;// Prop 预设值，若对应 props 没传入值将会使用 default 值App.defaultProps = &#123; todo: &#123;&#125;, name: '',&#125; 二、props和stateprops为父元素向下传递数据的方式 12345// 这里输出 Hello，lybconst MyComponent = () =&gt; ( &lt;div&gt;Hello, &#123;this.props.name&#125;!&lt;/div&gt;);ReactDOM.render(&lt;MyComponent name=\"lyb\"/&gt;, document.getElementById('app')); state为当前组件的状态，可以通过setState({name: &#39;lyb01&#39;})这样的方式来更新组件内容以下代码，会在按钮点击后，将lyb改变为lyb01 123456789101112131415161718192021222324252627282930class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; name: 'lyb' &#125; // 在构造函数中，需要将自有的方法绑定到当前的this中去 this.change = this.change.bind(this); &#125; change () &#123; // change后，组件本身会重新执行render进行渲染 this.setState(&#123; name: 'lyb01' &#125;); &#125; // jsx可以嵌入js表达式，但是需要用花括号包起来。需要注意的是，js的表达式为变量名、函数定义表达式 、属性访问表达式、函数调用表达式、算数表达式、关系表达式、逻辑表达式。但是，if和for循环这类不是js表达式，不可以直接写入jsx render () &#123; return ( &lt;div&gt; &#123;this.state.name&#125; &#123;/* jsx的注释，需要同样需要使用花括号包起来 */&#125; &lt;button onClick=&#123;this.change&#125;&gt;change&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('app')); 需要注意的是，代码中，不能直接的对this.state进行修改。在js中，对象和数组都是引用传递，当调用setState进行更新状态时候，不允许对前一个状态进行直接修改。通用的做法，是利用Object.assign({}, this.state, next.state)，得到一个state的拷贝，来进行状态更新。但是，Object.assign也只能对一层的json进行拷贝。对于更深的数据嵌套，可以借助于immutable.js进行处理。 三、生命周期钩子React每个组件，都具有三个状态，分别为 Mount 挂载组件 Update 正在被重新渲染 Unmount 销毁组件 其中，常用的有1234567componentDidMount () &#123; // 该函数会在组件挂载成功后调用&#125;ComponentWillUnmount () &#123; // 该函数会在组件销毁前进行执行&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Flex布局","date":"2017-03-05T11:42:24.000Z","path":"2017/03/05/Flex布局/","text":"父级元素设置display为flex或者inline-flex时，表示该元素将以弹性盒子方式布局。同时，该元素上的float、clear、vertical-align将全部失效。 123.box &#123; display: flex; /*inline-flex*/&#125; 基本概念： flex容器: 设置display为flex的父级元素为flex容器 flex项目: 容器中所有的子元素，为容器的flex项目，即flex item 主轴(main asix): flex项目的填充方向，默认为水平方向；主轴的起始位置(flex容器边框的交叉点)为main start，结束位置为main end 交叉轴(cross asix): 与主轴垂直交叉的轴，叫交叉轴 ；交叉轴的起始位置为cross start，结束位置为cross end 主轴空间: flex项目占据的主轴空间为main size；占据的交叉轴空间为cross size flex容器接收的属性：123456789.box &#123; display: flex; /*inline-flex*/ flex-direction: row; /*主轴的方向，默认row(从左到右)，可选row-reverse(从右到左)、column(从上到下)、column-reverse(从下到上)*/ flex-wrap: nowrap; /*是否换行，默认nowrap(不换行)，可选wrap(换行，第一行在上方)、wrap-reverse(换行，第一行在下方)*/ flex-flow: row nowrap; /*flex-direction和flex-wrap的连写*/ justiy-content: flex-start; /*容器内的项目在主轴上的对齐方式，默认flex-start(左对齐)，可选flex-end(右对齐)、center(居中)、space-between(两端对齐，左侧的去最左右侧去最右，项目间隔相等)、space-around(左右间隔平分)*/ align-items: stretch; /*容器内的项目在交叉轴上的对齐方式，默认stretch(拉伸，如果没设置高度，则垂直填充)，可选默认flex-start(上对齐)、flex-end(下对齐)、center(居中)、baseline(第一行文字下对齐对齐，即文字大小不同时，以文字下基线对齐)*/ align-content: stretch; /*多轴线对齐方式(多行)，如果只有一根轴线(单行)，则无效，可选flex-start、flex-end、center、space-between、space-around*/&#125; flex项目接收的属性：12345678.box &gt; .item &#123; order: 0; /*排序，越小越靠前，默认为0*/ flex-grow: 0; /*分配剩余空间的比例，默认为0，有剩余空间也不分配*/ flex-shrink: 1; /*缩小比例，如果容器空间不足，则按比例缩小，默认为1，如果为0则不缩小*/ flex-basis: auto; /*分配空间前，项目占据的主轴大小，默认为auto，即为项目本身的大小*/ flex: 0 1 auto; /*flex-grow, flex-shrink, flex-basis的连写*/ align-self: auto; /*允许单个项目与其他不一样的交叉轴对齐方式，默认auto为继承父元素的align-items*/&#125;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"flex","slug":"flex","permalink":"http://yoursite.com/tags/flex/"}]},{"title":"你好，2017","date":"2017-01-22T08:01:08.000Z","path":"2017/01/22/你好，2017/","text":"07年的暑假，那年我上高二，在一个大商场里，我看到了一双篮球鞋，Air Jordan 3 Retro Pure Money。到现在我都清晰的记得这双鞋的一切，纯白的鞋面，淡黄的爆裂纹充斥在鞋头和后跟，白色的鞋带上，有浅淡的紫色荧光斑点。我看了很久，很贵。 后来种种原因，我几乎不再去逛什么商场，但是这鞋子就像其他一些愿景一样，我总是幻想着下次看到不管多少钱都买回来，又担心买回来不舍得穿，又怕穿了后没有了刚看到它时对它的念想。 再次看到Air Jordan 3时，已经7年后了，在香港，海港城里，Air Jordan 3 Retro Grey Wolf，配色已经从洁白变成了灰色，鞋舌鞋带，还有四周的爆裂纹，都已经成了黑色。我开始后悔，当初怎么没有得到那简单、干净的洁白，只剩下这不黑不白的浅灰？她看到了我若有所思的样子，执意送给我，我拒绝了。 人总是在后悔那些后悔的事情。当开始后悔的时候，才发现想要弥补却再也无从下手了。 这两年过的很累，总是发生这样那样，让我措手不及的事情。没走出校园之前，不知是有意避之，还是真的一切顺利，还是自己没心没肺，总觉得没有什么会让自己头疼的事情。那时候好多设想，好多稚嫩的人生规划，都没了。然后，自己慢慢的学习，一点点转行。好在从去年开始，所有的一切都似乎慢慢的回到正确的轨道上来。我也更加清晰的认识到，这路虽然不是独木桥，更不是什么康庄大道。 前几天，岳母来了，送我了一双，Air Jordan 3 Retro Cyber Monday，纯黑色，没有爆裂纹。10年前，我为爆裂纹昼思夜想，10年后，我只想简简单单的努力过好每一天。10年前，我痴迷圣洁的白色，10年后，这一抹掩盖一切的纯黑，似乎更加值得品位。 希望今年一切顺利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"新的开始","date":"2016-12-15T14:48:22.000Z","path":"2016/12/15/new-start/","text":"妈的，这是天意么？之前的github帐号莫名其妙的被封了，申诉无数次无果，一怒之下删除了帐号。 思来想去，彩笔到底是离不开这个网站，不要脸的又注册了一个。 就当新的开始把，在苦逼的2016结束之际，希望能有更崭新的一面。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]